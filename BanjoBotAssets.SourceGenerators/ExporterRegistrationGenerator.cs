/* Copyright 2024 Tara "Dino" Cassatt
 * 
 * This file is part of BanjoBotAssets.
 * 
 * BanjoBotAssets is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * BanjoBotAssets is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with BanjoBotAssets.  If not, see <http://www.gnu.org/licenses/>.
 */
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

namespace BanjoBotAssets.SourceGenerators
{
    [Generator]
    public class ExporterRegistrationGenerator : IIncrementalGenerator
    {
        private const string TargetNamespace = "BanjoBotAssets.Extensions";

        private const string TargetClass = "ServiceCollectionExtensions";

        private const string TargetMethod = "AddExporterServices";

        private const string ExporterInterface = "global::BanjoBotAssets.Exporters.IExporter";

        private const string BaseExporterClass = "global::BanjoBotAssets.Exporters.BaseExporter";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            IncrementalValuesProvider<string?> servicesToRegister = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                    transform: static (ctx, cancellationToken) => GetSemanticTargetForGeneration(ctx, cancellationToken))
                .Where(static m => m is not null);

            context.RegisterSourceOutput(servicesToRegister.Collect(),
                static (spc, source) => Execute(spc, source));
        }

        // select all non-abstract class declarations that have any bases - we'll check if the bases are derived from BaseExporter later
        private static bool IsSyntaxTargetForGeneration(SyntaxNode syntax) =>
            syntax is ClassDeclarationSyntax cds &&
            cds.BaseList?.Types.Count > 0 &&
            !cds.Modifiers.Any(m => m.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.AbstractKeyword));

        // given a class declaration that has a base list, first check if the base list contains BaseExporter or
        // a derived type. if not, return null. if so, return the fully-qualified name of the class.
        private static string? GetSemanticTargetForGeneration(GeneratorSyntaxContext gsc, CancellationToken cancellationToken)
        { 
            var model = gsc.SemanticModel;
            var classDeclaration = (ClassDeclarationSyntax)gsc.Node;

            string? fullyQualifiedName = model.GetDeclaredSymbol(classDeclaration, cancellationToken)?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            if (fullyQualifiedName is null)
            {
                return null;
            }

            foreach (var baseType in classDeclaration.BaseList!.Types)
            {
                var typeInfo = model.GetTypeInfo(baseType.Type);
                if (typeInfo.Type is not INamedTypeSymbol baseTypeSymbol)
                {
                    continue;
                }

                // accept it if the base type is BaseExporter, or a type derived (directly or indirectly) from BaseExporter
                for (var current = baseTypeSymbol; current is not null; current = current.BaseType)
                {
                    var qualifiedName = current.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    if (qualifiedName == BaseExporterClass)
                    {
                        return fullyQualifiedName;
                    }
                }
            }

            return null;
        }

        private static void Execute(SourceProductionContext spc, ImmutableArray<string?> classes)
        {
            if (classes.IsEmpty)
            {
                // don't generate anything if this project doesn't contain any exporter classes
                return;
            }

            var sb = new StringBuilder();

            const string SXmlComment = $@"
        /// <summary>
        /// Registers all non-abstract classes that derive from <see cref=""{BaseExporterClass}""/>
        /// as implementations of <see cref=""{ExporterInterface}""/> with the specified service lifetime.
        /// </summary>
        /// <remarks>
        /// This method is automatically generated by <see cref=""{nameof(ExporterRegistrationGenerator)}""/>.
        /// </remarks>
        /// <param name=""services"">The <see cref=""IServiceCollection""/> to add the services to.</param>
        /// <param name=""lifetime"">The <see cref=""ServiceLifetime""/> to register the services with.</param>
        /// <returns>The <see cref=""IServiceCollection""/> so that additional calls can be chained.</returns>";

            sb.Append("namespace ")
                .AppendLine(TargetNamespace)
                .AppendLine("{")
                .AppendLine("    using Microsoft.Extensions.DependencyInjection;")
                .Append("    internal static partial class ")
                .AppendLine(TargetClass)
                .AppendLine("    {")
                .AppendLine(SXmlComment)
                .Append("        public static IServiceCollection ")
                .Append(TargetMethod)
                .AppendLine("(this IServiceCollection services, ServiceLifetime lifetime)")
                .AppendLine("        {");
            
            foreach (var className in classes.OrderBy(c => c).Distinct())
            {
                sb.Append("            services.Add(new ServiceDescriptor(")
                    .Append("typeof(")
                    .Append(ExporterInterface)
                    .Append("), typeof(")
                    .Append(className)
                    .Append("), lifetime));")
                    .AppendLine();
            }
            sb.AppendLine("            return services;")
                .AppendLine("        }")
                .AppendLine("    }")
                .AppendLine("}");

            spc.AddSource("ExporterRegistration.g.cs", sb.ToString());
        }
    }
}
