/* Copyright 2024 Tara "Dino" Cassatt
 * 
 * This file is part of BanjoBotAssets.
 * 
 * BanjoBotAssets is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * BanjoBotAssets is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with BanjoBotAssets.  If not, see <http://www.gnu.org/licenses/>.
 */
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

namespace BanjoBotAssets.SourceGenerators
{
    [Generator]
    public class NamedItemDataTypeMapGenerator : IIncrementalGenerator
    {
        private const string TargetNamespace = "BanjoBotAssets.Json";

        private const string TargetClass = "NamedItemDataConverter";

        private const string TargetMethod = "CreateNamedItemDataFromTypeField";

        private const string NamedItemDataAttribute = "BanjoBotAssets.Json.NamedItemDataAttribute";

        private record NamedItemDataToGenerate(string TypeFieldDiscriminator, string TypeName);

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            IncrementalValuesProvider<NamedItemDataToGenerate?> namedItemDatas = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    NamedItemDataAttribute,
                    predicate: static (s, _) => s is ClassDeclarationSyntax,
                    transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static m => m is not null);

            context.RegisterSourceOutput(namedItemDatas.Collect(),
                static (spc, source) => Execute(spc, source));
        }

        private static NamedItemDataToGenerate? GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext gsc)
        {
            var model = gsc.SemanticModel;
            var classSymbol = gsc.TargetSymbol;

            if (classSymbol is null)
                return null;

            var typeFieldDiscriminator = classSymbol.GetAttributes()
                .FirstOrDefault(a => $"{a.AttributeClass?.ContainingNamespace}.{a.AttributeClass?.MetadataName}" == NamedItemDataAttribute)
                ?.ConstructorArguments
                .FirstOrDefault()
                .Value
                ?.ToString();

            if (typeFieldDiscriminator is null)
                return null;

            return new NamedItemDataToGenerate(
                typeFieldDiscriminator,
                classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
        }

        private static void Execute(SourceProductionContext spc, ImmutableArray<NamedItemDataToGenerate?> namedItemDatas)
        {
            if (namedItemDatas.IsEmpty)
            {
                // don't generate anything if this project doesn't contain any NamedItemData classes
                return;
            }

            var sb = new StringBuilder();

            const string SXmlComment = $@"
        /// <summary>
        /// Creates a new instance of a class derived from <see cref=""NamedItemData""/> based on the value of the <c>Type</c> field.
        /// </summary>
        /// <remarks>
        /// This method is automatically generated by <see cref=""{nameof(NamedItemDataTypeMapGenerator)}""/>.
        /// </remarks>
        /// <param name=""discriminator"">The value of the <c>Type</c> field.</param>
        /// <returns>A new instance of a class derived from <see cref=""NamedItemData""/> if one exists for the specified discriminator;
        /// otherwise, <c>null</c>.</returns>";

            sb.AppendLine("#nullable enable")
                .Append("namespace ")
                .AppendLine(TargetNamespace)
                .AppendLine("{")
                .Append("    partial class ")
                .AppendLine(TargetClass)
                .AppendLine("    {")
                .AppendLine(SXmlComment)
                .Append("        private static NamedItemData? ")
                .Append(TargetMethod)
                .AppendLine("(string discriminator) => discriminator switch")
                .AppendLine("        {");

            foreach (var data in namedItemDatas.OfType<NamedItemDataToGenerate>()
                .OrderBy(d => d.TypeFieldDiscriminator)
                .Distinct())
            {
                sb.Append("            \"")
                    .Append(data.TypeFieldDiscriminator)
                    .Append("\" => new ")
                    .Append(data.TypeName)
                    .Append("(),")
                    .AppendLine();
            }

            sb.AppendLine("            _ => null,")
                .AppendLine("        };")
                .AppendLine("    }")
                .AppendLine("}");

            spc.AddSource("NamedItemDataTypeMap.g.cs", sb.ToString());
        }
    }
}
